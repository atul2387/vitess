// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vtctlservice.proto

package vtctlservice

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtctldata "vitess.io/vitess/go/vt/proto/vtctldata"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("vtctlservice.proto", fileDescriptor_27055cdbb1148d2b) }

var fileDescriptor_27055cdbb1148d2b = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x97, 0xdd, 0x4e, 0x1b, 0x39,
	0x14, 0xc7, 0xc9, 0xc5, 0xa2, 0x5d, 0xc3, 0x2e, 0xbb, 0x66, 0xb5, 0x1f, 0x81, 0x04, 0x08, 0xb0,
	0x5b, 0xfa, 0x41, 0x2a, 0x7a, 0xd9, 0xab, 0x90, 0xa6, 0x29, 0x42, 0x42, 0x34, 0x20, 0x90, 0x90,
	0x2a, 0xd5, 0xcc, 0x1c, 0x92, 0x11, 0xce, 0xcc, 0x30, 0x76, 0x52, 0xa2, 0xbe, 0x48, 0x1f, 0xa9,
	0x97, 0x7d, 0x84, 0x8a, 0xde, 0xf6, 0x21, 0xaa, 0x8c, 0x63, 0x63, 0x7b, 0xec, 0x90, 0x2b, 0x88,
	0x7f, 0xff, 0xf3, 0x3f, 0xfe, 0x3a, 0x27, 0x0e, 0xc2, 0x43, 0x1e, 0x70, 0xca, 0x20, 0x1b, 0x46,
	0x01, 0xec, 0xa6, 0x59, 0xc2, 0x13, 0xbc, 0xa8, 0x8f, 0x95, 0x97, 0xf2, 0x4f, 0x21, 0xe1, 0x44,
	0xe0, 0xbd, 0x1b, 0xf4, 0xd3, 0xd9, 0x78, 0x08, 0xf7, 0xd0, 0x72, 0xeb, 0x16, 0x82, 0x01, 0x87,
	0xfc, 0x73, 0x33, 0xe9, 0xf7, 0x49, 0x1c, 0xe2, 0xed, 0xdd, 0xfb, 0x08, 0x07, 0xef, 0xc0, 0xcd,
	0x00, 0x18, 0x2f, 0xff, 0xf7, 0x90, 0x8c, 0xa5, 0x49, 0xcc, 0xa0, 0x36, 0xf7, 0xbc, 0xb4, 0xf7,
	0xfd, 0x1f, 0x34, 0x9f, 0xc3, 0x10, 0x1f, 0xa1, 0x85, 0x46, 0x18, 0x36, 0x81, 0xd2, 0x83, 0xf8,
	0x2a, 0xc1, 0x15, 0xcd, 0x45, 0x1b, 0x97, 0x49, 0xaa, 0x3e, 0x2c, 0xcd, 0xf1, 0x29, 0xfa, 0x75,
	0x02, 0x58, 0x83, 0x46, 0x84, 0xe1, 0xb5, 0x62, 0x88, 0x20, 0xd2, 0x73, 0xdd, 0x2f, 0x50, 0xae,
	0xef, 0xd1, 0x1f, 0x8d, 0x34, 0xa5, 0xa3, 0x4e, 0x32, 0xe0, 0x51, 0xdc, 0xed, 0x0c, 0x28, 0x30,
	0xbc, 0xa9, 0x07, 0xda, 0x54, 0xba, 0x6f, 0x4d, 0x17, 0xa9, 0x0c, 0xef, 0xd0, 0xef, 0xcd, 0x1e,
	0x89, 0xbb, 0x70, 0x4a, 0x2e, 0x29, 0xf0, 0xd3, 0x51, 0x0a, 0xb8, 0xa6, 0xc5, 0xda, 0x50, 0xfa,
	0x6f, 0x4e, 0xd5, 0x28, 0xfb, 0x73, 0xf4, 0x5b, 0x33, 0x03, 0xc2, 0xe1, 0x10, 0x46, 0x2c, 0x25,
	0x01, 0x60, 0x7d, 0xd9, 0x26, 0x92, 0xd6, 0x1b, 0x53, 0x14, 0xca, 0xf8, 0x08, 0x2d, 0x08, 0x76,
	0xd2, 0x23, 0x59, 0x68, 0x9c, 0x9f, 0x36, 0xee, 0x3a, 0x3f, 0x03, 0xeb, 0x13, 0x7d, 0x05, 0x14,
	0x3c, 0x13, 0x35, 0x91, 0x6b, 0xa2, 0xb6, 0x42, 0x19, 0xbf, 0x45, 0x8b, 0x82, 0xe5, 0x19, 0x19,
	0xae, 0x16, 0x82, 0x04, 0x90, 0xa6, 0x6b, 0x5e, 0xae, 0xdf, 0x35, 0x41, 0xc4, 0x96, 0x9b, 0x77,
	0xcd, 0x20, 0xae, 0xbb, 0x66, 0x09, 0x94, 0x6b, 0x82, 0xfe, 0x6a, 0xf5, 0x21, 0xeb, 0x42, 0x1c,
	0x8c, 0x3a, 0x90, 0x92, 0x0c, 0x62, 0x2e, 0x36, 0xf7, 0x91, 0x5e, 0x62, 0x4e, 0x89, 0xcc, 0xb3,
	0x33, 0x83, 0x52, 0x25, 0xcc, 0xd0, 0xdf, 0xaf, 0xa3, 0x38, 0x6c, 0x50, 0x2a, 0x56, 0x78, 0x10,
	0xab, 0xbd, 0xd7, 0x7d, 0x3c, 0x1a, 0x99, 0xf2, 0xf1, 0x2c, 0x52, 0x95, 0xf3, 0x10, 0xa1, 0x36,
	0xf0, 0x7d, 0x12, 0x5c, 0x0f, 0x52, 0x86, 0x57, 0xb5, 0xd8, 0xfb, 0x61, 0xe9, 0x5c, 0xf1, 0x50,
	0xbd, 0x76, 0xda, 0xc0, 0x65, 0x33, 0x38, 0x22, 0x7d, 0x60, 0x46, 0xed, 0xd8, 0xd0, 0x55, 0x3b,
	0x45, 0x8d, 0x7e, 0xc5, 0x35, 0x8a, 0x2b, 0xee, 0x28, 0xd7, 0x15, 0x37, 0xb0, 0xf2, 0xbb, 0x40,
	0x4b, 0x13, 0x20, 0xfa, 0x0c, 0x30, 0xbc, 0x51, 0x0c, 0x92, 0x4c, 0xfa, 0xd6, 0xa6, 0x49, 0xac,
	0xb9, 0xaa, 0xf3, 0xb3, 0xe6, 0x6a, 0x9f, 0x59, 0xd5, 0x87, 0xf5, 0xaa, 0xd1, 0x80, 0x59, 0x35,
	0x3a, 0x70, 0x55, 0x8d, 0xc9, 0xad, 0xe5, 0x1b, 0x9d, 0xd4, 0x5a, 0xbe, 0xab, 0x8f, 0xd6, 0xa6,
	0x49, 0x94, 0xf7, 0x1b, 0xf4, 0x4b, 0x1b, 0xf8, 0x49, 0xd0, 0x83, 0x3e, 0xc1, 0x2b, 0x66, 0x88,
	0x18, 0x95, 0x7e, 0xab, 0x6e, 0xa8, 0x9c, 0x5a, 0xe8, 0xe7, 0xf1, 0x70, 0x5e, 0x77, 0x65, 0x4b,
	0xab, 0x57, 0xda, 0x8a, 0x93, 0x59, 0x8b, 0x3d, 0xc9, 0x86, 0xf7, 0x5b, 0x68, 0x2d, 0x56, 0x67,
	0x9e, 0xc5, 0x9a, 0x12, 0xbd, 0xfd, 0x08, 0x78, 0x36, 0x59, 0xf0, 0x5a, 0x21, 0xec, 0xcc, 0x5c,
	0xf4, 0xba, 0x5f, 0xa0, 0x37, 0x60, 0x03, 0x31, 0xec, 0x8d, 0x62, 0xae, 0x06, 0x6c, 0x2b, 0xac,
	0xb3, 0x11, 0xfd, 0xce, 0x3e, 0x1b, 0x31, 0xea, 0x39, 0x1b, 0x09, 0xad, 0xe6, 0x21, 0x9b, 0xae,
	0x53, 0xed, 0x6b, 0x1e, 0xc5, 0x76, 0x2b, 0xcc, 0xe4, 0x16, 0x5a, 0x66, 0xd6, 0xfe, 0x55, 0x3c,
	0xd4, 0x2a, 0x97, 0xf3, 0x24, 0xbb, 0xbe, 0xa2, 0xc9, 0x87, 0x42, 0xb9, 0x28, 0xe0, 0x29, 0x17,
	0x8d, 0xeb, 0xcd, 0xed, 0x20, 0x8e, 0xc4, 0xc5, 0x3a, 0xce, 0xa2, 0x3e, 0xc9, 0x46, 0x46, 0x73,
	0xb3, 0xa1, 0xab, 0xb9, 0x15, 0x35, 0xca, 0x3e, 0x42, 0x7f, 0x1e, 0x53, 0x12, 0xc7, 0x10, 0x9a,
	0xdf, 0x35, 0xfa, 0x73, 0xce, 0x25, 0x90, 0x69, 0xfe, 0x7f, 0x50, 0xa7, 0x52, 0x5d, 0xa1, 0xe5,
	0x0e, 0x5c, 0x0e, 0x22, 0x1a, 0x4e, 0x36, 0xae, 0x9d, 0x91, 0xb4, 0x67, 0xbc, 0x2f, 0x1d, 0xdc,
	0xf5, 0xbe, 0x74, 0xca, 0x54, 0x9e, 0x00, 0xe1, 0x0e, 0xf4, 0x93, 0xa1, 0x7a, 0x05, 0x8c, 0x7b,
	0x25, 0xde, 0x32, 0xe2, 0x6d, 0x2c, 0xb3, 0x6c, 0x3f, 0xa0, 0xd2, 0x0b, 0x5b, 0xf0, 0x7c, 0x95,
	0x79, 0x86, 0x8d, 0x42, 0xac, 0x62, 0xae, 0xc2, 0x2e, 0x48, 0xf4, 0x12, 0x94, 0x7b, 0x38, 0x29,
	0x97, 0x75, 0x23, 0x4e, 0x47, 0xae, 0x12, 0xb4, 0x15, 0xca, 0xf8, 0x16, 0xfd, 0x3b, 0x39, 0x94,
	0x94, 0x46, 0x01, 0xe1, 0x51, 0x12, 0x1f, 0x27, 0x2c, 0x1a, 0xff, 0x65, 0xf8, 0x89, 0xe6, 0xe0,
	0x55, 0xc9, 0x74, 0x4f, 0x67, 0x13, 0xab, 0xcc, 0x1f, 0x51, 0x59, 0xcc, 0xa6, 0x75, 0xcb, 0x21,
	0x8b, 0x09, 0xa5, 0xea, 0x39, 0x02, 0x21, 0xd6, 0xdd, 0xfc, 0x32, 0x99, 0xfb, 0xd9, 0x8c, 0x6a,
	0x99, 0x7c, 0xff, 0xe5, 0xe7, 0xbb, 0x6a, 0xe9, 0xcb, 0x5d, 0xb5, 0xf4, 0xf5, 0xae, 0x5a, 0xfa,
	0xf4, 0xad, 0x3a, 0x77, 0xb1, 0x33, 0x8c, 0x38, 0x30, 0xb6, 0x1b, 0x25, 0x75, 0xf1, 0x5f, 0xbd,
	0x9b, 0xd4, 0x87, 0xbc, 0x9e, 0xff, 0x22, 0xaa, 0xeb, 0xbf, 0x97, 0x2e, 0xe7, 0xf3, 0xb1, 0x17,
	0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x08, 0xe3, 0x21, 0x5a, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VtctlClient is the client API for Vtctl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VtctlClient interface {
	ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error)
}

type vtctlClient struct {
	cc *grpc.ClientConn
}

func NewVtctlClient(cc *grpc.ClientConn) VtctlClient {
	return &vtctlClient{cc}
}

func (c *vtctlClient) ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vtctl_serviceDesc.Streams[0], "/vtctlservice.Vtctl/ExecuteVtctlCommand", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctlExecuteVtctlCommandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctl_ExecuteVtctlCommandClient interface {
	Recv() (*vtctldata.ExecuteVtctlCommandResponse, error)
	grpc.ClientStream
}

type vtctlExecuteVtctlCommandClient struct {
	grpc.ClientStream
}

func (x *vtctlExecuteVtctlCommandClient) Recv() (*vtctldata.ExecuteVtctlCommandResponse, error) {
	m := new(vtctldata.ExecuteVtctlCommandResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VtctlServer is the server API for Vtctl service.
type VtctlServer interface {
	ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error
}

// UnimplementedVtctlServer can be embedded to have forward compatible implementations.
type UnimplementedVtctlServer struct {
}

func (*UnimplementedVtctlServer) ExecuteVtctlCommand(req *vtctldata.ExecuteVtctlCommandRequest, srv Vtctl_ExecuteVtctlCommandServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteVtctlCommand not implemented")
}

func RegisterVtctlServer(s *grpc.Server, srv VtctlServer) {
	s.RegisterService(&_Vtctl_serviceDesc, srv)
}

func _Vtctl_ExecuteVtctlCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.ExecuteVtctlCommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctlServer).ExecuteVtctlCommand(m, &vtctlExecuteVtctlCommandServer{stream})
}

type Vtctl_ExecuteVtctlCommandServer interface {
	Send(*vtctldata.ExecuteVtctlCommandResponse) error
	grpc.ServerStream
}

type vtctlExecuteVtctlCommandServer struct {
	grpc.ServerStream
}

func (x *vtctlExecuteVtctlCommandServer) Send(m *vtctldata.ExecuteVtctlCommandResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Vtctl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctl",
	HandlerType: (*VtctlServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteVtctlCommand",
			Handler:       _Vtctl_ExecuteVtctlCommand_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtctlservice.proto",
}

// VtctldClient is the client API for Vtctld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VtctldClient interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace, as well as from the SrvKeyspace for that
	// keyspace in that cell.
	RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error)
}

type vtctldClient struct {
	cc *grpc.ClientConn
}

func NewVtctldClient(cc *grpc.ClientConn) VtctldClient {
	return &vtctldClient{cc}
}

func (c *vtctldClient) AddCellInfo(ctx context.Context, in *vtctldata.AddCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.AddCellInfoResponse, error) {
	out := new(vtctldata.AddCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) AddCellsAlias(ctx context.Context, in *vtctldata.AddCellsAliasRequest, opts ...grpc.CallOption) (*vtctldata.AddCellsAliasResponse, error) {
	out := new(vtctldata.AddCellsAliasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/AddCellsAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ApplyRoutingRules(ctx context.Context, in *vtctldata.ApplyRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.ApplyRoutingRulesResponse, error) {
	out := new(vtctldata.ApplyRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ApplyRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ChangeTabletType(ctx context.Context, in *vtctldata.ChangeTabletTypeRequest, opts ...grpc.CallOption) (*vtctldata.ChangeTabletTypeResponse, error) {
	out := new(vtctldata.ChangeTabletTypeResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ChangeTabletType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateKeyspace(ctx context.Context, in *vtctldata.CreateKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.CreateKeyspaceResponse, error) {
	out := new(vtctldata.CreateKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) CreateShard(ctx context.Context, in *vtctldata.CreateShardRequest, opts ...grpc.CallOption) (*vtctldata.CreateShardResponse, error) {
	out := new(vtctldata.CreateShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/CreateShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteKeyspace(ctx context.Context, in *vtctldata.DeleteKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.DeleteKeyspaceResponse, error) {
	out := new(vtctldata.DeleteKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteShards(ctx context.Context, in *vtctldata.DeleteShardsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteShardsResponse, error) {
	out := new(vtctldata.DeleteShardsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) DeleteTablets(ctx context.Context, in *vtctldata.DeleteTabletsRequest, opts ...grpc.CallOption) (*vtctldata.DeleteTabletsResponse, error) {
	out := new(vtctldata.DeleteTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/DeleteTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) EmergencyReparentShard(ctx context.Context, in *vtctldata.EmergencyReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.EmergencyReparentShardResponse, error) {
	out := new(vtctldata.EmergencyReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/EmergencyReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	out := new(vtctldata.FindAllShardsInKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/FindAllShardsInKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetBackups(ctx context.Context, in *vtctldata.GetBackupsRequest, opts ...grpc.CallOption) (*vtctldata.GetBackupsResponse, error) {
	out := new(vtctldata.GetBackupsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetBackups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfoNames(ctx context.Context, in *vtctldata.GetCellInfoNamesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoNamesResponse, error) {
	out := new(vtctldata.GetCellInfoNamesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfoNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellInfo(ctx context.Context, in *vtctldata.GetCellInfoRequest, opts ...grpc.CallOption) (*vtctldata.GetCellInfoResponse, error) {
	out := new(vtctldata.GetCellInfoResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetCellsAliases(ctx context.Context, in *vtctldata.GetCellsAliasesRequest, opts ...grpc.CallOption) (*vtctldata.GetCellsAliasesResponse, error) {
	out := new(vtctldata.GetCellsAliasesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetCellsAliases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error) {
	out := new(vtctldata.GetKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error) {
	out := new(vtctldata.GetKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetRoutingRules(ctx context.Context, in *vtctldata.GetRoutingRulesRequest, opts ...grpc.CallOption) (*vtctldata.GetRoutingRulesResponse, error) {
	out := new(vtctldata.GetRoutingRulesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetRoutingRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSchema(ctx context.Context, in *vtctldata.GetSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSchemaResponse, error) {
	out := new(vtctldata.GetSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetShard(ctx context.Context, in *vtctldata.GetShardRequest, opts ...grpc.CallOption) (*vtctldata.GetShardResponse, error) {
	out := new(vtctldata.GetShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvKeyspaces(ctx context.Context, in *vtctldata.GetSrvKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvKeyspacesResponse, error) {
	out := new(vtctldata.GetSrvKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchema(ctx context.Context, in *vtctldata.GetSrvVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemaResponse, error) {
	out := new(vtctldata.GetSrvVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetSrvVSchemas(ctx context.Context, in *vtctldata.GetSrvVSchemasRequest, opts ...grpc.CallOption) (*vtctldata.GetSrvVSchemasResponse, error) {
	out := new(vtctldata.GetSrvVSchemasResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetSrvVSchemas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablet(ctx context.Context, in *vtctldata.GetTabletRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletResponse, error) {
	out := new(vtctldata.GetTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetTablets(ctx context.Context, in *vtctldata.GetTabletsRequest, opts ...grpc.CallOption) (*vtctldata.GetTabletsResponse, error) {
	out := new(vtctldata.GetTabletsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetTablets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetVSchema(ctx context.Context, in *vtctldata.GetVSchemaRequest, opts ...grpc.CallOption) (*vtctldata.GetVSchemaResponse, error) {
	out := new(vtctldata.GetVSchemaResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetVSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetWorkflows(ctx context.Context, in *vtctldata.GetWorkflowsRequest, opts ...grpc.CallOption) (*vtctldata.GetWorkflowsResponse, error) {
	out := new(vtctldata.GetWorkflowsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetWorkflows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error) {
	out := new(vtctldata.InitShardPrimaryResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/InitShardPrimary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) PlannedReparentShard(ctx context.Context, in *vtctldata.PlannedReparentShardRequest, opts ...grpc.CallOption) (*vtctldata.PlannedReparentShardResponse, error) {
	out := new(vtctldata.PlannedReparentShardResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/PlannedReparentShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RebuildVSchemaGraph(ctx context.Context, in *vtctldata.RebuildVSchemaGraphRequest, opts ...grpc.CallOption) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	out := new(vtctldata.RebuildVSchemaGraphResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RebuildVSchemaGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveKeyspaceCell(ctx context.Context, in *vtctldata.RemoveKeyspaceCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	out := new(vtctldata.RemoveKeyspaceCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveKeyspaceCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) RemoveShardCell(ctx context.Context, in *vtctldata.RemoveShardCellRequest, opts ...grpc.CallOption) (*vtctldata.RemoveShardCellResponse, error) {
	out := new(vtctldata.RemoveShardCellResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/RemoveShardCell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ReparentTablet(ctx context.Context, in *vtctldata.ReparentTabletRequest, opts ...grpc.CallOption) (*vtctldata.ReparentTabletResponse, error) {
	out := new(vtctldata.ReparentTabletResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ReparentTablet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) ShardReplicationPositions(ctx context.Context, in *vtctldata.ShardReplicationPositionsRequest, opts ...grpc.CallOption) (*vtctldata.ShardReplicationPositionsResponse, error) {
	out := new(vtctldata.ShardReplicationPositionsResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/ShardReplicationPositions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) TabletExternallyReparented(ctx context.Context, in *vtctldata.TabletExternallyReparentedRequest, opts ...grpc.CallOption) (*vtctldata.TabletExternallyReparentedResponse, error) {
	out := new(vtctldata.TabletExternallyReparentedResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/TabletExternallyReparented", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VtctldServer is the server API for Vtctld service.
type VtctldServer interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(context.Context, *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(context.Context, *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(context.Context, *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(context.Context, *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(context.Context, *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(context.Context, *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(context.Context, *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(context.Context, *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(context.Context, *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(context.Context, *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetBackups returns all the backups for a shard.
	GetBackups(context.Context, *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(context.Context, *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(context.Context, *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(context.Context, *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(context.Context, *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(context.Context, *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error)
	// GetShard returns information about a shard in the topology.
	GetShard(context.Context, *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(context.Context, *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(context.Context, *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(context.Context, *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error)
	// GetTablet returns information about a tablet.
	GetTablet(context.Context, *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(context.Context, *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(context.Context, *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(context.Context, *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(context.Context, *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(context.Context, *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace, as well as from the SrvKeyspace for that
	// keyspace in that cell.
	RemoveKeyspaceCell(context.Context, *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(context.Context, *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(context.Context, *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(context.Context, *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(context.Context, *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error)
}

// UnimplementedVtctldServer can be embedded to have forward compatible implementations.
type UnimplementedVtctldServer struct {
}

func (*UnimplementedVtctldServer) AddCellInfo(ctx context.Context, req *vtctldata.AddCellInfoRequest) (*vtctldata.AddCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellInfo not implemented")
}
func (*UnimplementedVtctldServer) AddCellsAlias(ctx context.Context, req *vtctldata.AddCellsAliasRequest) (*vtctldata.AddCellsAliasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCellsAlias not implemented")
}
func (*UnimplementedVtctldServer) ApplyRoutingRules(ctx context.Context, req *vtctldata.ApplyRoutingRulesRequest) (*vtctldata.ApplyRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRoutingRules not implemented")
}
func (*UnimplementedVtctldServer) ChangeTabletType(ctx context.Context, req *vtctldata.ChangeTabletTypeRequest) (*vtctldata.ChangeTabletTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTabletType not implemented")
}
func (*UnimplementedVtctldServer) CreateKeyspace(ctx context.Context, req *vtctldata.CreateKeyspaceRequest) (*vtctldata.CreateKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKeyspace not implemented")
}
func (*UnimplementedVtctldServer) CreateShard(ctx context.Context, req *vtctldata.CreateShardRequest) (*vtctldata.CreateShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateShard not implemented")
}
func (*UnimplementedVtctldServer) DeleteKeyspace(ctx context.Context, req *vtctldata.DeleteKeyspaceRequest) (*vtctldata.DeleteKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeyspace not implemented")
}
func (*UnimplementedVtctldServer) DeleteShards(ctx context.Context, req *vtctldata.DeleteShardsRequest) (*vtctldata.DeleteShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteShards not implemented")
}
func (*UnimplementedVtctldServer) DeleteTablets(ctx context.Context, req *vtctldata.DeleteTabletsRequest) (*vtctldata.DeleteTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTablets not implemented")
}
func (*UnimplementedVtctldServer) EmergencyReparentShard(ctx context.Context, req *vtctldata.EmergencyReparentShardRequest) (*vtctldata.EmergencyReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencyReparentShard not implemented")
}
func (*UnimplementedVtctldServer) FindAllShardsInKeyspace(ctx context.Context, req *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAllShardsInKeyspace not implemented")
}
func (*UnimplementedVtctldServer) GetBackups(ctx context.Context, req *vtctldata.GetBackupsRequest) (*vtctldata.GetBackupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackups not implemented")
}
func (*UnimplementedVtctldServer) GetCellInfoNames(ctx context.Context, req *vtctldata.GetCellInfoNamesRequest) (*vtctldata.GetCellInfoNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfoNames not implemented")
}
func (*UnimplementedVtctldServer) GetCellInfo(ctx context.Context, req *vtctldata.GetCellInfoRequest) (*vtctldata.GetCellInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellInfo not implemented")
}
func (*UnimplementedVtctldServer) GetCellsAliases(ctx context.Context, req *vtctldata.GetCellsAliasesRequest) (*vtctldata.GetCellsAliasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCellsAliases not implemented")
}
func (*UnimplementedVtctldServer) GetKeyspace(ctx context.Context, req *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspace not implemented")
}
func (*UnimplementedVtctldServer) GetKeyspaces(ctx context.Context, req *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspaces not implemented")
}
func (*UnimplementedVtctldServer) GetRoutingRules(ctx context.Context, req *vtctldata.GetRoutingRulesRequest) (*vtctldata.GetRoutingRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutingRules not implemented")
}
func (*UnimplementedVtctldServer) GetSchema(ctx context.Context, req *vtctldata.GetSchemaRequest) (*vtctldata.GetSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchema not implemented")
}
func (*UnimplementedVtctldServer) GetShard(ctx context.Context, req *vtctldata.GetShardRequest) (*vtctldata.GetShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShard not implemented")
}
func (*UnimplementedVtctldServer) GetSrvKeyspaces(ctx context.Context, req *vtctldata.GetSrvKeyspacesRequest) (*vtctldata.GetSrvKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvKeyspaces not implemented")
}
func (*UnimplementedVtctldServer) GetSrvVSchema(ctx context.Context, req *vtctldata.GetSrvVSchemaRequest) (*vtctldata.GetSrvVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchema not implemented")
}
func (*UnimplementedVtctldServer) GetSrvVSchemas(ctx context.Context, req *vtctldata.GetSrvVSchemasRequest) (*vtctldata.GetSrvVSchemasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSrvVSchemas not implemented")
}
func (*UnimplementedVtctldServer) GetTablet(ctx context.Context, req *vtctldata.GetTabletRequest) (*vtctldata.GetTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablet not implemented")
}
func (*UnimplementedVtctldServer) GetTablets(ctx context.Context, req *vtctldata.GetTabletsRequest) (*vtctldata.GetTabletsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablets not implemented")
}
func (*UnimplementedVtctldServer) GetVSchema(ctx context.Context, req *vtctldata.GetVSchemaRequest) (*vtctldata.GetVSchemaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVSchema not implemented")
}
func (*UnimplementedVtctldServer) GetWorkflows(ctx context.Context, req *vtctldata.GetWorkflowsRequest) (*vtctldata.GetWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflows not implemented")
}
func (*UnimplementedVtctldServer) InitShardPrimary(ctx context.Context, req *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitShardPrimary not implemented")
}
func (*UnimplementedVtctldServer) PlannedReparentShard(ctx context.Context, req *vtctldata.PlannedReparentShardRequest) (*vtctldata.PlannedReparentShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlannedReparentShard not implemented")
}
func (*UnimplementedVtctldServer) RebuildVSchemaGraph(ctx context.Context, req *vtctldata.RebuildVSchemaGraphRequest) (*vtctldata.RebuildVSchemaGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildVSchemaGraph not implemented")
}
func (*UnimplementedVtctldServer) RemoveKeyspaceCell(ctx context.Context, req *vtctldata.RemoveKeyspaceCellRequest) (*vtctldata.RemoveKeyspaceCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKeyspaceCell not implemented")
}
func (*UnimplementedVtctldServer) RemoveShardCell(ctx context.Context, req *vtctldata.RemoveShardCellRequest) (*vtctldata.RemoveShardCellResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveShardCell not implemented")
}
func (*UnimplementedVtctldServer) ReparentTablet(ctx context.Context, req *vtctldata.ReparentTabletRequest) (*vtctldata.ReparentTabletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReparentTablet not implemented")
}
func (*UnimplementedVtctldServer) ShardReplicationPositions(ctx context.Context, req *vtctldata.ShardReplicationPositionsRequest) (*vtctldata.ShardReplicationPositionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardReplicationPositions not implemented")
}
func (*UnimplementedVtctldServer) TabletExternallyReparented(ctx context.Context, req *vtctldata.TabletExternallyReparentedRequest) (*vtctldata.TabletExternallyReparentedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TabletExternallyReparented not implemented")
}

func RegisterVtctldServer(s *grpc.Server, srv VtctldServer) {
	s.RegisterService(&_Vtctld_serviceDesc, srv)
}

func _Vtctld_AddCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellInfo(ctx, req.(*vtctldata.AddCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_AddCellsAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.AddCellsAliasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).AddCellsAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/AddCellsAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).AddCellsAlias(ctx, req.(*vtctldata.AddCellsAliasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ApplyRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ApplyRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ApplyRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ApplyRoutingRules(ctx, req.(*vtctldata.ApplyRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ChangeTabletType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ChangeTabletTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ChangeTabletType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ChangeTabletType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ChangeTabletType(ctx, req.(*vtctldata.ChangeTabletTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateKeyspace(ctx, req.(*vtctldata.CreateKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_CreateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.CreateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).CreateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/CreateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).CreateShard(ctx, req.(*vtctldata.CreateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteKeyspace(ctx, req.(*vtctldata.DeleteKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteShards(ctx, req.(*vtctldata.DeleteShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_DeleteTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.DeleteTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).DeleteTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/DeleteTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).DeleteTablets(ctx, req.(*vtctldata.DeleteTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_EmergencyReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.EmergencyReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/EmergencyReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).EmergencyReparentShard(ctx, req.(*vtctldata.EmergencyReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_FindAllShardsInKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.FindAllShardsInKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/FindAllShardsInKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, req.(*vtctldata.FindAllShardsInKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetBackups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetBackups(ctx, req.(*vtctldata.GetBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfoNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfoNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfoNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfoNames(ctx, req.(*vtctldata.GetCellInfoNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellInfo(ctx, req.(*vtctldata.GetCellInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetCellsAliases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetCellsAliasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetCellsAliases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetCellsAliases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetCellsAliases(ctx, req.(*vtctldata.GetCellsAliasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspace(ctx, req.(*vtctldata.GetKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspaces(ctx, req.(*vtctldata.GetKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetRoutingRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetRoutingRules(ctx, req.(*vtctldata.GetRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSchema(ctx, req.(*vtctldata.GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetShard(ctx, req.(*vtctldata.GetShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvKeyspaces(ctx, req.(*vtctldata.GetSrvKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchema(ctx, req.(*vtctldata.GetSrvVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetSrvVSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetSrvVSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetSrvVSchemas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetSrvVSchemas(ctx, req.(*vtctldata.GetSrvVSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablet(ctx, req.(*vtctldata.GetTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetTablets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetTabletsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetTablets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetTablets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetTablets(ctx, req.(*vtctldata.GetTabletsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetVSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetVSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetVSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetVSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetVSchema(ctx, req.(*vtctldata.GetVSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetWorkflows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetWorkflows(ctx, req.(*vtctldata.GetWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_InitShardPrimary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.InitShardPrimaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).InitShardPrimary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/InitShardPrimary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).InitShardPrimary(ctx, req.(*vtctldata.InitShardPrimaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_PlannedReparentShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.PlannedReparentShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).PlannedReparentShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/PlannedReparentShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).PlannedReparentShard(ctx, req.(*vtctldata.PlannedReparentShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RebuildVSchemaGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RebuildVSchemaGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RebuildVSchemaGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RebuildVSchemaGraph(ctx, req.(*vtctldata.RebuildVSchemaGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveKeyspaceCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveKeyspaceCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveKeyspaceCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveKeyspaceCell(ctx, req.(*vtctldata.RemoveKeyspaceCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_RemoveShardCell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.RemoveShardCellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).RemoveShardCell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/RemoveShardCell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).RemoveShardCell(ctx, req.(*vtctldata.RemoveShardCellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ReparentTablet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ReparentTabletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ReparentTablet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ReparentTablet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ReparentTablet(ctx, req.(*vtctldata.ReparentTabletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_ShardReplicationPositions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.ShardReplicationPositionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/ShardReplicationPositions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).ShardReplicationPositions(ctx, req.(*vtctldata.ShardReplicationPositionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_TabletExternallyReparented_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.TabletExternallyReparentedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/TabletExternallyReparented",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).TabletExternallyReparented(ctx, req.(*vtctldata.TabletExternallyReparentedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Vtctld_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctld",
	HandlerType: (*VtctldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCellInfo",
			Handler:    _Vtctld_AddCellInfo_Handler,
		},
		{
			MethodName: "AddCellsAlias",
			Handler:    _Vtctld_AddCellsAlias_Handler,
		},
		{
			MethodName: "ApplyRoutingRules",
			Handler:    _Vtctld_ApplyRoutingRules_Handler,
		},
		{
			MethodName: "ChangeTabletType",
			Handler:    _Vtctld_ChangeTabletType_Handler,
		},
		{
			MethodName: "CreateKeyspace",
			Handler:    _Vtctld_CreateKeyspace_Handler,
		},
		{
			MethodName: "CreateShard",
			Handler:    _Vtctld_CreateShard_Handler,
		},
		{
			MethodName: "DeleteKeyspace",
			Handler:    _Vtctld_DeleteKeyspace_Handler,
		},
		{
			MethodName: "DeleteShards",
			Handler:    _Vtctld_DeleteShards_Handler,
		},
		{
			MethodName: "DeleteTablets",
			Handler:    _Vtctld_DeleteTablets_Handler,
		},
		{
			MethodName: "EmergencyReparentShard",
			Handler:    _Vtctld_EmergencyReparentShard_Handler,
		},
		{
			MethodName: "FindAllShardsInKeyspace",
			Handler:    _Vtctld_FindAllShardsInKeyspace_Handler,
		},
		{
			MethodName: "GetBackups",
			Handler:    _Vtctld_GetBackups_Handler,
		},
		{
			MethodName: "GetCellInfoNames",
			Handler:    _Vtctld_GetCellInfoNames_Handler,
		},
		{
			MethodName: "GetCellInfo",
			Handler:    _Vtctld_GetCellInfo_Handler,
		},
		{
			MethodName: "GetCellsAliases",
			Handler:    _Vtctld_GetCellsAliases_Handler,
		},
		{
			MethodName: "GetKeyspace",
			Handler:    _Vtctld_GetKeyspace_Handler,
		},
		{
			MethodName: "GetKeyspaces",
			Handler:    _Vtctld_GetKeyspaces_Handler,
		},
		{
			MethodName: "GetRoutingRules",
			Handler:    _Vtctld_GetRoutingRules_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _Vtctld_GetSchema_Handler,
		},
		{
			MethodName: "GetShard",
			Handler:    _Vtctld_GetShard_Handler,
		},
		{
			MethodName: "GetSrvKeyspaces",
			Handler:    _Vtctld_GetSrvKeyspaces_Handler,
		},
		{
			MethodName: "GetSrvVSchema",
			Handler:    _Vtctld_GetSrvVSchema_Handler,
		},
		{
			MethodName: "GetSrvVSchemas",
			Handler:    _Vtctld_GetSrvVSchemas_Handler,
		},
		{
			MethodName: "GetTablet",
			Handler:    _Vtctld_GetTablet_Handler,
		},
		{
			MethodName: "GetTablets",
			Handler:    _Vtctld_GetTablets_Handler,
		},
		{
			MethodName: "GetVSchema",
			Handler:    _Vtctld_GetVSchema_Handler,
		},
		{
			MethodName: "GetWorkflows",
			Handler:    _Vtctld_GetWorkflows_Handler,
		},
		{
			MethodName: "InitShardPrimary",
			Handler:    _Vtctld_InitShardPrimary_Handler,
		},
		{
			MethodName: "PlannedReparentShard",
			Handler:    _Vtctld_PlannedReparentShard_Handler,
		},
		{
			MethodName: "RebuildVSchemaGraph",
			Handler:    _Vtctld_RebuildVSchemaGraph_Handler,
		},
		{
			MethodName: "RemoveKeyspaceCell",
			Handler:    _Vtctld_RemoveKeyspaceCell_Handler,
		},
		{
			MethodName: "RemoveShardCell",
			Handler:    _Vtctld_RemoveShardCell_Handler,
		},
		{
			MethodName: "ReparentTablet",
			Handler:    _Vtctld_ReparentTablet_Handler,
		},
		{
			MethodName: "ShardReplicationPositions",
			Handler:    _Vtctld_ShardReplicationPositions_Handler,
		},
		{
			MethodName: "TabletExternallyReparented",
			Handler:    _Vtctld_TabletExternallyReparented_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vtctlservice.proto",
}
